# 程序介绍与算法说明

本程序的目的是计算对数螺旋的参数并绘制相应图形，主要流程如下：

1. 定义中心螺旋线长度函数：
   - 公式： 
     $$ L_c(b) = \sqrt{1+b^2} \cdot \frac{s_{\max} - s_{\min}}{2b} \cdot \frac{e^{2\pi b} + 1}{e^{2\pi b} - 1} $$
   - 实现：
     ```python
     # 实现：中心螺旋线长度函数实现
     def Lc(b):
         return np.sqrt(1 + b**2) * (s_max - s_min) / (2 * b) * (np.exp(2*np.pi*b) + 1) / (np.exp(2*np.pi*b) - 1)
     ```
2. 利用 Brent 法求解参数 b，使得 L_c(b) 等于预设的中心螺旋线长度 L_center。
   - 代码中使用了 scipy.optimize.brentq 求解零点。
3. 根据求得的 b，计算参数 a，其公式为：
   - 公式：
     $$ a = \frac{s_{\min}}{e^{2\pi b} - 1} $$
4. 计算终止角度 θ_end：
   - 公式：
     $$ \theta_{\rm end} = \frac{1}{b} \ln\!\bigl(\tfrac{s_{\max}}{s_{\min}}\bigr) $$
5. 将螺旋线在区间 [0, θ_end] 内等分为若干小段，分别计算每个节点的边缘和中心径向坐标。
6. 利用极坐标到笛卡尔坐标的转换公式：
   - 公式： 
     $$ x(\theta) = r(\theta)\cos\theta,\quad y(\theta) = r(\theta)\sin\theta $$
7. 绘制每一小段四边形，并将图形导出为 DXF 文件，方便后续的工程应用。
8. 边缘螺旋线设计过程：
   - 公式：
     $$ r_{\rm edge}(\theta) = a\, e^{b\theta} $$
   - 设计过程：利用指数函数描述螺旋线的扩张，确保在旋转过程中每一圈的径向距离逐渐增大，从而满足最小和最大间距的要求。
9. 中心螺旋线设计过程：
   - 公式：
     $$ r_{\rm center}(\theta) = \frac{r_{\rm edge}(\theta) + r_{\rm edge}(\theta+2\pi)}{2} $$
   - 设计过程：通过取相邻两圈边缘的平均值，获得中间轨迹，实现平滑过渡及增强结构稳定性。
10. 设计过程实现代码：
    - 以下代码片段展示了如何计算边缘螺旋线和中心螺旋线：
      ```python
      # 实现：计算边缘与中心螺旋线
      r_edge_seg   = a * np.exp(b * theta_seg)
      r_center_seg = 0.5 * (r_edge_seg + a * np.exp(b * (theta_seg + 2*np.pi)))
      ```

$$
\begin{align}
L_c(b) = \int_0^{2\pi} \sqrt{r(\theta)^2 + \bigl(r'(\theta)\bigr)^2}\,d\theta
\end{align}
$$
$$
\begin{align}

\end{align}
$$
# 附录
计算程序：
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import brentq
from solid import polygon, rotate, rotate_extrude, translate, union, scad_render_to_file
from pathlib import Path
import ezdxf

# ─────────────指定参数 ──────────────────
s_min        = 12.0      # 最小圈间径向间距 (mm)
s_max        = 66.0     # 最大圈间径向间距 (mm)
L_center     = 200.0    # center 螺旋线长度 (mm)
num_segments = 12       # 将螺旋分成多少段，可按需修改
# ────────────────────────────────────────

# 根据指定的 center 螺旋线长度计算 b, a, θ_end

def Lc(b):
    # 中心螺旋线长度函数 L_c(b)
    # LaTeX:  L_c(b) = \int_0^{2\pi} \sqrt{r(\theta)^2 + \bigl(r'(\theta)\bigr)^2}\,d\theta
    # 经过解析可得：
    # L_c(b) = \sqrt{1 + b^2} 
    #           \,\frac{s_{\max} - s_{\min}}{2b}
    #           \,\frac{e^{2\pi b} + 1}{e^{2\pi b} - 1}
    return np.sqrt(1 + b**2) * (s_max - s_min) / (2 * b) * (np.exp(2*np.pi*b) + 1) / (np.exp(2*np.pi*b) - 1)

# 求解 b 使得 L_c(b) = L_center
# LaTeX:  \text{find } b: L_c(b) - L_{\rm center} = 0
b = brentq(lambda bb: Lc(bb) - L_center, 1e-6, 1.0)

# 计算 a
# LaTeX:  a = \frac{s_{\min}}{e^{2\pi b} - 1}
a = s_min / (np.exp(2*np.pi*b) - 1)

# 计算 θ_end
# LaTeX:  \theta_{\rm end} = \frac{1}{b} \ln\!\bigl(\tfrac{s_{\max}}{s_{\min}}\bigr)
theta_end = np.log(s_max / s_min) / b

print(f"计算结果： a = {a:.4f},  b = {b:.4f}, θ_end = {theta_end:.4f}")

# 将螺旋线分割成等角度小段
# LaTeX:  \theta_i = i\,\Delta\theta,\quad \Delta\theta = \frac{\theta_{\rm end}}{\text{num\_segments}}
theta_seg = np.linspace(0, theta_end, num_segments + 1)

# 计算每个节点的径向坐标
# LaTeX:  r_{\rm edge}(\theta)   = a\,e^{b\theta}
# LaTeX:  r_{\rm center}(\theta) = \tfrac12\bigl(r_{\rm edge}(\theta) + r_{\rm edge}(\theta + 2\pi)\bigr)
r_edge_seg   = a * np.exp(b * theta_seg)
r_center_seg = 0.5 * (r_edge_seg + a * np.exp(b * (theta_seg + 2*np.pi)))

# 极坐标转笛卡尔坐标
# LaTeX:  x(\theta) = r(\theta)\cos\theta,\quad y(\theta) = r(\theta)\sin\theta
x_edge_seg = r_edge_seg * np.cos(theta_seg)
y_edge_seg = r_edge_seg * np.sin(theta_seg)
x_ctr_seg  = r_center_seg * np.cos(theta_seg)
y_ctr_seg  = r_center_seg * np.sin(theta_seg)

# 绘制每个小段为四边形，连接相同 θ 的 edge 和 center 点
plt.figure(figsize=(6,6))
for i in range(num_segments):
    xs = [
        x_edge_seg[i],
        x_edge_seg[i+1],
        x_ctr_seg[i+1],
        x_ctr_seg[i],
        x_edge_seg[i]
    ]
    ys = [
        y_edge_seg[i],
        y_edge_seg[i+1],
        y_ctr_seg[i+1],
        y_ctr_seg[i],
        y_edge_seg[i]
    ]
    plt.plot(xs, ys, '-k')

plt.axis('equal')
plt.xlabel('X (mm)')
plt.ylabel('Y (mm)')
plt.title(f'对数螺旋细分为{num_segments}个四边形')
plt.grid(True)

# 新增：导出 DXF 文件
doc = ezdxf.new(dxfversion='R2010')
msp = doc.modelspace()
for i in range(num_segments):
    pts = [
        (x_edge_seg[i], y_edge_seg[i]),
        (x_edge_seg[i+1], y_edge_seg[i+1]),
        (x_ctr_seg[i+1], y_ctr_seg[i+1]),
        (x_ctr_seg[i], y_ctr_seg[i]),
        (x_edge_seg[i], y_edge_seg[i])
    ]
    msp.add_lwpolyline(pts, close=True)

dxf_output_path = "line.dxf"
doc.saveas(dxf_output_path)
print(f"DXF文件已导出到 {dxf_output_path}")

plt.show()
```